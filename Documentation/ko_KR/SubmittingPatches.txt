NOTE:
This is a version of Documentation/SubmittingPatches (from Linux-3.7.5),
translated into Korean.
Note that the purpose of this file is to be easier to read in Korean and
is not intended as a fork. If you have any comments or updates for this file
please try to update the original English file first.
If this translation is outdated or has any problem with translation,
contact the translator or maintainer of this file.
===
이 문서는 Documentation/SubmittingPatches (Linux-3.7.5)의
한글 번역본입니다.
이 문서의 내용에 문제나 수정할 것이 있다면 먼저 영어 원문을 확인하고 수정하는
것이 맞습니다. 번역이 잘못되었거나, 영어 원문이 개정되었다면 아래 번역자 또는
문서 관리자에게 연락하시기 바랍니다.

Translated by: Minsuk Lee <minsuk@hansung.ac.kr>
Translated on: SUN 2013 JAN 27

===

	리눅스 커널에 당신이 변경한 내용을 반영하는 법
		또는
	Linus Torvalds를 아끼면서 활용하기

개인이든 회사든 리눅스 커널에 대한 수정 내용을 제출하고자 할 때, 
"그 시스템"에 익숙하지 않으면, 그 과정은 어쩌면 쉽지 않은 일 일겁니다.
이 문서는 당신이 수정한 내용이 채택될 가능성을 크게 높일 수 있는
제안들을 담고 있습니다.

우선 코드를 제출하기 전에 체크해야 할 목록을 확인하기 위하여
Documentation/SubmitChecklist 문서를 보시기 바랍니다.
만약 드라이버를 제출한다면 Documentation/SubmittingDrivers도
읽으시기 바랍니다. (두 문서는 Documentation/ko_KR/에 한글 버전이
준비되어 있습니다. - 역자 주)

-----------------------------------
제 1 절 - 수정 내용을 만들고 보내기
-----------------------------------

1) "diff -up"
-------------

패치는 "diff -up" 또는 "diff -uprN" 명령을 이용하여 만듭니다.

모든 리눅스 커널 수정은 diff(1)에 의해 생성된 것과 같은 패치의 형태로
만들어집니다. 패치는 반드시 diff(1)에 '-u' 옵션을 이용하여 생성되는 
"unified diff" 포맷으로 만들어야합니다. 또한 어느 C 함수에 수정된 내용이
포함되어 있는지를 보여주는 '-p' 옵션을 사용하시면, 출력된 결과가 훨씬
읽기 쉬워집니다. 패치는 커널 소스 디렉토리의 최상위 디렉토리 기준이어야
하며, 어디든 하위의 서브 디렉토리여서는 안됩니다.
 
한 파일에 대한 패치를 만들 때는, 다음과 같이 하면 보통 문제가 없습니다:

	SRCTREE= linux-2.6
	MYFILE=  drivers/net/mydriver.c

	cd $SRCTREE
	cp $MYFILE $MYFILE.orig
	vi $MYFILE	# make your change
	cd ..
	diff -up $SRCTREE/$MYFILE{.orig,} > /tmp/patch

여러 파일에 대한 한 패치를 만들 때는 "바닐라" 라고 불리는 수정되지 않은
커널 소스 트리의 압축을 풀고, 수정된 당신의 소스 트리를 대상으로 diff를
다음과 같이 합니다:

	MYSRC= /devel/linux-2.6

	tar xvfz linux-2.6.12.tar.gz
	mv linux-2.6.12 linux-2.6.12-vanilla
	diff -uprN -X linux-2.6.12-vanilla/Documentation/dontdiff \
		linux-2.6.12-vanilla $MYSRC > /tmp/patch

"dontdiff" 파일은 커널 빌드 과정에서 생성된 파일들의 목록이며, diff(1)에 의해서
생성될 패치에 포함되지 않아야 하는 것들입니다. "dontdiff" 파일은 2.6.12 이후의
커널 버전에 포함되어 있습니다. 그 이전 버전의 커널에 대해서는 같은 내용을
<http://www.xenotime.net/linux/doc/dontdiff>에서 찾을 수 있습니다.

패치에는 패치 제출 목적과 상관없는 어떤 추가적인 파일도 포함되지 않아야
합니다. 정확성을 기하기 위해 diff(1)로 패치를 만든 뒤에 반드시 리뷰를 하시기
바랍니다.

변경된 내용이 아주 많을 때는, 논리적인 단계로 구분된 여러 개의 개별적인 패치로
나누는 방법을 생각해볼 수 있습니다. 이 방법은 다른 커널 개발자들이 리뷰를 더
쉽게할 수 있게 만들기 때문에, 당신의 패치가 받아들여지기를 원한다면 중요하게
고려해야 합니다. 이 작업에 도움되는 스크립트들이 여럿 있습니다.

Quilt:
http://savannah.nongnu.org/projects/quilt

Andrew Morton의 패치 스크립트:
http://userweb.kernel.org/~akpm/stuff/patch-scripts.tar.gz

여러 스크립트들이 있지만, 위에 언급된 quilt를 패치 관리 도구로 추천합니다.

2) 변경한 내용에 대한 기술

제출하는 패치에 포함된 변경 사항들에 대하여 기술적인 상세 설명이 필요합니다.

가능한 자세히 설명하시기 바랍니다. 최악의 설명은 "update driver X (드라이버
X의 개정)", "bug fix for driver X (드라이버 X의 버그 수정)",
"this patch includes updates for subsystem X. Please apply. (이 패치는
서브시스템 X를 개정한 것이므로, 적용바랍니다.)" 와 같은 것입니다.

관리자는 리눅스의 소스코드 관리 시스템인 git에 "commit log"로 바로 옮겨 쓸
수 있는 형태의 패치 설명을 해주면 고마워 할 겁니다. 아래 15번 항목을 보세요.

설명이 길어진다면, 그것은 아마 패치를 여러 조각으로 분리해야할 필요가 있다는
것을 암시합니다. 아래 3번 항목을 보세요.

어떤 한 패치 또는 일련의 패치를 제출하거나, 다시 제출할 때, 완전한 패치
설명과 그 패치가 필요한 이유를 적어야 합니다. 단지 어떤 패치의 N 번째
버전이라고만 적어서는 안됩니다. 패치를 적용하는 사람이 패치 설명을
찾기 위하여 이전 패치 버전이나 참조된 URL을 뒤져, 그 내용을 패치에
포함시켜 줄 거라고 기대해서는 안됩니다. 즉, 하나(또는 일련)의 패치는
그 각각이 독립적으로 모든 내용을 포함하고 있어야 합니다.
이 방법은 패치를 적용하는 사람이나 리뷰를 하는 사람에게 모두 도움이 됩니다.
어떤 리뷰어는 아마 그 패치의 이전 버전을 받지 않았을지도 모릅니다.

만약 패치가 로깅된 버그를 수정한 것이라면, 그 버그 엔트리의
번호와 URL을 명시하기 바랍니다.

3) 패치의 분리

어떤 변경이 논리적으로 구분된다면, 구분되는 각각을 독립된 하나 씩의
패치 파일로 만드세요.

예를 들어, 한 드라이버에 대하여 버그를 수정함과 동시에 성능을 개선했다면
그에 대한 수정 내용을 두 개 또는 그 이상의 패치로 구분해야 합니다.
만약 어떤 API를 수정하고, 새로 만든 드라이버가 그 API를 사용한다면, 
그 경우에도 두 개의 패치로 분리되어야 합니다.

한편으로, 여러 파일들을 수정해야하는 하나의 변경을 한 경우에는 그 모든
수정 내용을 하나의 패치로 만들어야 합니다. 그래야, 하나의 논리적인 변경이 
하나의 패치로 적용될 수 있습니다.
 
하나의 패치가 완결되기 위하여 다른 패치를 먼저 적용해야하는 종속성이
있다해도 좋습니다. 그런 경우 "This patch depends on patch X
(이 패치가 패치 X에 의존적이다.)" 라고 명시를 해주면 됩니다.  

만약 당신이 만든 패치가 작은 단위의 패치 집합으로 모아질 수 없다면, 우선
한번에 15개 정도의 패치를 먼저 보내 리뷰되어 통합되기를 기다리시기를
바랍니다.

4) 변경 내용에 대한 스타일 검사

패치에 기본적인 스타일 오류가 있는지 확인하세요. 코딩 스타일은 
Documentation/CodingStyle에서 볼 수 있습니다. (이 문서의 한글 버전은
Documentation/ko_KR/에 준비되어 있습니다. - 역자 주) 스타일 검사를 하지
않으면 리뷰어들의 시간을 낭비할 뿐만 아니라 당신의 패치가 읽히지도
않고 거절당하게 됩니다.

5) 누구에게 이메일을 보낼 것인가

당신의 변경 내용이 커널의 어느 서브시스템에 적용되는지를 확인한 뒤, 소스
코드와 MAINTAINERS 파일을 찾아보면, 지정된 관리자가 누구인지 알 수 있습니다.
그 사람에게 이메일을 보내면 됩니다. script/get_maintainer.pl 스크립트가
매우 유용할 겁니다.

관리자가 명시되어 있지 않거나, 관리자가 이메일에 응답을 하지 하지 않으면,
기본 리눅스 커널 개발자 메일링 리스트인 linux-kernel@vger.kernel.org에
패치를 보내시기 바랍니다. 대부분의 커널 개발자들은 이 이메일 리스트를
보고 있으며, 당신의 변경 내용에 대하여 코멘트할 겁니다.

vger 메일링 리스트로 한번에 15개 이상의 패치를 보내지 마시기 바랍니다.

Linus Torvalds는 리눅스 커널에 적용된 모든 변경에 대한 최종 결정권자입니다.
그의 이메일 주소는 <torvalds@linux-foundation.org> 입니다. 그는 아주 많은
이메일을 받기 때문에, 그에게 메일을 보내기 전에 다른 방법들을 먼저 찾아보는
것이 좋을 겁니다.

6) CC (이메일 참조) 리스트 선택

별 다른 이유가 없다면, linux-kernel@vger.kernel.org를 이메일의 참조(cc)에
넣으세요.

Linus뿐만 아니라 다른 커널 개발자들도 당신이 수정한 내용을 알 필요가 있으며,
그들도 그 내용에 대하여 코멘트를 할 수도 있고, 그 코드를 리뷰나 제안을 할 수
있을 것입니다. linux-kernel이 커널 개발자들의 기본 메일링 리스트 입니다.
USB, 프레임버퍼 디바이스, VFS, SCSI 서브시스템 등과 같이 특정 서브시스템에는
별도의 메일링 리스트가 있습니다. MAINTAINERS 파일에서 당신의 변경과 관련이
있는 메일링 리스트를 찾을 수 있습니다.

VGER.KERNEL.ORG에 대한 메일링 리스트는 다음 사이트에서 볼 수 있습니다.
	<http://vger.kernel.org/vger-lists.html>

만일 변경 내용이 사용자 영역과 커널 사이의 인터페이스에 해당된다면 MAN-PAGES
관리자(역시 MAINTAINER 파일에 있는)에게 man-page 패치를 보내거나 변경에
관하여 알려주어야 합니다. 그렇게 해야, 매뉴얼 페이지에 해당  내용이 반영될
수 있습니다.

사소한 작은 패치에 대해서는, 사소한 패치들을 모으는 '사소한 패치 몽키'인
trivial@kernel.org를 cc 하실 수 있습니다. 역시 MAINTAINER 파일에서 현재의
관리자를 확인할 수 있습니다. 사소한 패치로 인정하는 것들은 다음과 같습니다:
  문서에 대한 스펠링 오류의 수정
  grep(1)에 문제를 일으킬 수 있는 스펠링 오류의 수정
  컴파일 워닝 수정 (별 의미없는 워닝이 남발되는 것은 좋지 않으므로)
  컴파일 오류 수정 (실제로 컴파일러에 의한 오류일 때)
  런타임 오류 수정 (실제로 뭔가 오류를 수정할 때)
  더 이상 사용되지 않는 함수나 매크로 사용을 제거 (예, check_region)
  연락처 또는 문서화 내용의 수정
  이식 가능하지 않은 코드를 이식 가능하게 수정 (사람들이 복사를 하므로,
  사소한 수정이라면, 아키텍처 종속적인 것도 포함)
  파일의 저자나 관리자에 의한 수정 (즉, 패치 몽키의 재전송 모드)

7) MIME, 링크, 압축, 첨부 등은 없이, 그냥 텍스트만을 사용

Linus나 다른 커널 개발자들은 당신이 제출하는 변경 내역만 읽고 코멘트 합니다.
따라서, 표준 이메일 도구만을 이용하여 커널 개발자들이 변경된 내역을
인용하여, 당신의 코드의 특정 일부분에 대하여 코멘트할 수 있도록 하는 것이
중요합니다.

이런 이유 때문에 모든 패치는 이메일의 "본문"에 포함되도록 제출되어야 합니다.
경고: 패치를 cut&paste로 옮기는 경우 사용하고 있는 편집기의 자동 줄바꿈 기능
때문에 패치가 깨지는 경우가 있음을 주의해야 합니다.

패치를 압축하던 그렇지 않던 MIME 첨부로 보내서는 안됩니다. 많은 유명한
이메일 프로그램들이 MIME 첨부 내용을 항상 보통 텍스트 형식으로 전송하지는
않기 때문에, 당신의 코드에 코멘트를 할 수 없는 경우가 발생합니다.
또 MIME 첨부를 처리하기 위해 Linus가 더 많은 시간을 써야한다는 것은,
MIME 첨부된 변경 내용이 받아들여지지 않을 가능성을 높힙니다.

예외: 가끔 메일러가 패치 내용을 심하게 훼손하는 경우엔, MIME을 써서
재전송해달라고 요구하는 경우도 있습니다.

메일러가 패치를 있는 그대로 전송하기 위하여 이메일을 설정하는 법은
Documentation/email-clients.txt 파일을 참조하시기 바랍니다.

8) 이메일 크기

Linus에게 패치를 보낼 때는 항상 위 7번을 따르시기 바랍니다.

대규모의 수정 내용을 이메일로 보내느 것은 메일링 리스트나 어떤 관리자에게는
맞지 않습니다. 압축하지 않은 패치의 크기가 300KB를 넘은 경우에는 패치를
인터넷에서 접근 가능한 서버에 저장하고 그 패치를 가리키는 URL(링크)만 보내는
방법이 좋을 것입니다. 

9) 커널 버전의 명시

제목이나, 패치 설명에 이 패치가 적용되는 커널 버전을 명시하는 것이 중요합니다.

만약 패치가 가장 최신의 커널 버전에 깔끔하게 적용되지 않는다면, Linus는
그것을 적용하지 않을 겁니다.

10) 용기를 잃지말고, 다시 제출하세요.

일단 변경 내용을 보낸 뒤에는 참을성 있게 기다려야 합니다. Linus가 당신의
변경 내용을 만족하게 생각해서 적용을 한다면 그것은 그가 릴리즈하는 다음
버전의 커널에 포함될 것입니다.

그렇지만, 그 변경 내용이 다음 커널 버전에 나타나지 않았다면, 아마 여러
이유가 있을 겁니다. 그 이유를 줄이고, 잘못된 내용을 수정하고, 개정된 내용을
다시 보내시기 바랍니다.

아무 코멘트 없이 Linus가 당신의 패치를 날려버리는 것은 꽤 흔한 일입니다.
그게 시스템이 돌아가는 방식입니다. 당신의 패치가 적용되지 않았다면 그것은
아마 다음과 같은 이유일 겁니다.
* 패치를 가장 최근의 리눅스 커널에서 깨끗하게 적용할 수 없었던 경우
* linux-kernel 메일링 리스트에서 충분히 논의가 안된 경우
* 코딩 스타일 문제 (2절 참조)
* 이메일 포맷의 문제 (이 절을 다시 읽으세요)
* 변경 내용에 기술적인 문제가 있는 경우
* 그가 너무 많은 메일을 받아, 그 와중에 이메일이 없어진 경우
* 당신이 짜증스럽게 구는 경우

판단이 잘 안설 때는, linux-kernel 메일링 리스트에 코멘트를 요구하세요.

Linus와 linux-kernel에 대한 많은 메일때문에 [PATCH]라는 접두어를 메일 제목에
붙이는 것이 보통 관행입니다. 이렇게 함으로써 Linus나 다른 커널 개발자들이
다른 이메일 논의들과 패치를 쉽게 구분할 수 있게 됩니다.

12) 작업에 대한 서명

특히 커널 내부의 마지막 안식처에 잘 녹아들어갈 때까지 여러 계층의 관리자를
거쳐야 하는 패치에 더 필요하겠지만, 누가 뭘 했는지 추적하는 걸 쉽게 하기
위하여, 이메일로 전달되는 패치에 대하여 "sign-off"라는 절차가 마련되어
있습니다.

Sign-off는 패치 설명 맨 뒤에 붙이는 간단한 한 줄로 당신이 그 패치를 직접
만들었거나, 공개 소스 패치로 전달할 권리를 가지고 있다는 것을 증명하는
것입니다. 규칙은 매우 간단합니다. 실명으로 다음 라인을 추가하면 됩니다.
(죄송하지만, 별명을 사용하거나 익명의 공헌은 사절합니다.)

	Signed-off-by: Random J Developer <random@developer.example.org>

Sign-off는 당신이 아래 내용을 증명할 수 있다는 것을 의미합니다.

	원작자 증명 1.1
	
	이 프로젝트에 기여를 함에 있어, 다음 내용을 증명합니다.

	(a) 이 기여 내용은 전체적으로 또는 부분적으로 나에 의해 만들어졌고
		나는 그것을 파일에 표기한 대로 공개 소스 저작권에 따라 제출할
		권한을 가지고 있습니다; 또는

	(b) 이 기여 내용은 이전의 작업 결과물에 기반한 것이며, 내가 아는 한,
		그 이전 결과물도 적합한 공개 소스 저작권에 의한 보호를 받으며,
		나도 그 저작권에 따라, 전체적으로 또는 부분적으로 나에 의해
		만들어진 수정 내용과 함께 그 작업 결과물을, 파일에 표기한 대로
		같은 공개 소스 저작권으로 (다른 저작권으로 제출할 권리가 주어지지
		않았다면) 제출할 권리가 있습니다; 또는
	
	(c) 이 기여 내용은 (a), (b) 또는 (c)를 증명하는 다른 사람으로부터
        전달받은 것이며, 나는 수정하지 않았습니다.
	
	(d) 나는 이 프로젝트와 나의 기여 내용이 공개된 것이며, 이 기여 기록(내가
		같이 제출한 sign-off를 포함한 개인 정보까지)이 지속적으로 유지되고, 
		이 프로젝트와 함께 또는 연관된 공개 소스 저작권에 따른 형태로
		재배포될 수 있음을 이해하고 동의합니다.

어떤 사람들은 뒤에 추가적인 태그를 덧붙이기도 합니다. 지금으로선, 그것들이
그냥 무시됩니다만, 회사의 내부 절차를 표시하기 위해 또는 sign-off와 관련된
세부 사항을 명시하기 위해서라면 하셔도 좋습니다.

만약 당신이 서브시스템이나 브랜치 관리자인 경우, 당신의 소스 트리와 제출자의
소스 트리가 정확하게 같지 않기 때문에, 가끔은 패치를 통합하는 과정에서
약간의 수정이 필요한 경우가 있습니다. 이때 위 원작자 증명 (c)를 준수한다면, 
아마 제출자에게 diff를 새로 할 것을 요구해야 하지만, 이는 매우 비생산적인
일이 될겁니다. 또 규칙 (b)에 따르면, 코드에 대한 수정이 허락되기는 하지만 
제출한 사람의 코드를 수정하는 것은 매우 무례한 일일뿐만 아니라, 어쩌면
당신이 추가한 버그를 그에게 전가하는 것입니다. 이 문제를 해결하기 위해서,
마지막 Signed-off-by 헤더와 당신의 헤더 사이에 한 줄을 추가하여, 당신이
변경한 내용의 성격에 대하여 기술할 것을 권고합니다. 이 절차와 관련해서는
어떤 의무 조항도 있지는 않지만, 당신의 이메일 그리고(또는) 이름과 해당
설명을 꺽쇠 괄호 안에 다음과 같이 넣어 당신이 마지막 순간에 행한 약간의
수정에 대하여 책임이 있다는 것을 명백하게 표시하면 좋습니다. 

	Signed-off-by: Random J Developer <random@developer.example.org>
	[lucky@maintainer.example.org: struct foo moved from foo.c to foo.h]
	Signed-off-by: Lucky K Maintainer <lucky@maintainer.example.org>

이러한 관행은 안정적인 브랜치 관리를 가능하게 하면서 저작자의 공헌을 기리고,
수정 내용을 추적하고 통합하며, 제출자를 비난으로부터 보호하는데 특히
도움이 됩니다. 저작자의 신분 사항(From 헤더)는 changelog에 나오게 되는
것이므로 어떤 경우에도 변경해서는 안됩니다.

이전 버전에 이식하는 사람들에 대한 특별한 주의 사항: 커밋 메시지의 최상단
(Subject 라인 바로 다음)에 추적을 용이하기 하기 위하여, 패치의 원래 소스가
어디에서 온 것인지에 관한 표시를 넣는 것이 통상적으로 사용되는 유용한
관행입니다. 예를 들어 2.6-stable 버전에서 다음 내용을 볼 수 있습니다:

    Date:   Tue May 13 19:10:30 2008 +0000

        SCSI: libiscsi regression in 2.6.25: fix nop timer handling

        commit 4cf1043593db6a337f10e006c23c69e5fc93e722 upstream

그리고 2.4 버전에는 다음과 같은 것이 있습니다:

    Date:   Tue May 13 22:12:27 2008 +0200

        wireless, airo: waitbusy() won't delay

        [backport of 2.6 commit b7acbdfbd1f277c1eb23f344f899cfa4cd0bf36a]

형식이야 어쨌든, 이런 정보는 사람들이 당신의 소스 트리를 추적하고, 그 소스
트리의 버그를 수정하는데 큰 도움이 됩니다. 

13) Acked-by: 와 Cc:를 사용하는 경우

Signed-off-by 태그는 사인한 사람이 그 패치의 개발에 관계되어 있거나,
그 패치의 배포 경로 상에 있다는 것을 표시합니다.

어떤 사람이 그 패치를 준비했거나 처리하는데 직접적으로 관여하지는 않았지만,
그 패치를 승인했다는 기록을 남기고 사인하기를 원하다면, 해당 패치의
changelog에 Acked-by: 라인으로 그 내용을 남길 수 있습니다.

Acked-by:는 관리자가 그 패치에 뭔가 기여하지 않았고, 전달 과정에도 관여하지
않은 경우에 자주 사용됩니다.

Acked-by:는 공식적인 Signed-off-by:가 아닙니다. 이것은 승인자가 적어도
그 패치를 리뷰하고 받아들였다는 것을 표시합니다. 따라서 패치를 통합하는
사람이 승인자의 "예, 제가보긴엔 문제 없어요"라는 메시지를 손으로
Acked-by:로 바꾸기도 합니다.

Acked-by:는 전체 패치에 대한 승인을 반드시 의미하지는 않습니다. 예를 들어,
어떤 패치가 여러 서브시스템에 영향을 주고 있다면, 한 서브시스템
관리자로부터의 Acked-by:는 그 관리자의 관할에 있는 코드 영역에 대한 승인을
의미합니다. 여기에 어떤 판단이 필요합니다. 확실하지 않을 때는 반드시 
메일링 리스트 아카이브에서 원래의 토의 과정을 살펴봐야 합니다.

만약 어떤 사람이 한 패치에 대하여 코멘트를 할 기회가 있었지만, 그 코멘트를
제공하지 않았다면, 선택적으로 Cc: 태그를 패치에 붙일 수 있습니다.
이 Cc: 태그는 태그가 포함하는 사람의 명시적인 행위 없이도 붙일 수 있는 유일한
태그입니다. 이 태그는 논의 과정에서 이 패치에 관심이 있었던 사람이나 조직을
기록하기 위해 사용됩니다.

14) Reported-by:, Tested-by: 그리고 Reviewed-by:의 사용

이 패치가 다른 누군가에 의해 보고된 문제를 수정하는 것이었다면, 그 문제를
보고한 사람의 공헌을 기리기 위해 Reported-by: 태그를 붙이는 것을 고려합니다.
특별히 주의해야할 것은, 그 문제가 공개된 포럼에서 보고되지 않은 경우, 그
문제를 보고한 사람의 허가없이 더해져서는 안됩니다. 이 태그는 문제를 보고한
사람을 기리기 위한 것이며, 그 결과 앞으로도 우리를 도와줄 의지가 또 생기도록
독려하고자 하는 것입니다.

Tested-by: 태그는 태그에 명시된 사람에 의해 이 패치가 (어떤 환경에서)
성공적으로 테스트 되었다는 것을 표시합니다. 이 태그는 관리자에게 어떤
테스트가 진행되었으며, 앞으로의 패치에 대해서도 누구에게 테스트를 맡길
것인가를 알려주고, 테스터의 공헌을 기리기 위함입니다.

반면에 Reviewed-By:는 패치가 리뷰되고, 다음 리뷰어 진술에 따라 수용이
가능하다는 것을 표시합니다.

    관리에 관한 리뷰어 진술

    Reviewed-by: 태그를 붙임으로써, 나는 다음과 같이 진술합니다:
	
    (a) 나는 이 패치에 대하여 그 적정성과 메인라인 커널에 포함될 수 있는
        수준으로 준비가 되어있는지를 평가하기 위한 기술적 리뷰를 수행했습니다.
	
    (b) 나는 패치와 관련된 모든 문제, 우려 또는 질문을 제출자에게 전달했으며
        그 코멘트들에 관한 제출자의 대응은 만족스러웠습니다.
	
    (c) 이 제출과 관련하여 개선될 점이 있을 수는 있지만, 이 시점에서 (1) 커널에
        대한 수정이 가치로운 것이며, (2) 이것을 커널에 포함시킴으로써 생길 수
        있는 문제점은 알려진 바 없다고 믿습니다.
	
    (d) 내가 리뷰를 했고, 문제가 없다고 믿고 있지만, (명시적으로 표시한 경우를
        제외하고는) 어떤 주어진 환경에서 이 패치가 추구하던 목적이나 기능을 
        달성한다는 어떠한 보장이나 보증을 하지 않습니다.

Reviewed-by: 태그는 이 패치가 커널에 적용되어도 심각한 기술적 이슈가 생기지
않을 것이라는 의견을 명시한 것입니다. 어떤 관심있는 (해당 작업을 했던) 리뷰어도
패치에 대하여 Reviewed-by 태그를 붙일 수 있습니다. 이 태그는 리뷰어를 기리기
위한 것이며, 관리자에게 이 패치에 대하여 어느 정도의 리뷰가 이루어졌는지를
알려주기 위함이기도 합니다. 통상적으로 Reviewed-by: 태그가 해당 기술 분야를
이해하고 있다고 알려진 리뷰어에 의해 추가될 때, 당신의 패치가 커널에 포함될
가능성이 높아지게 됩니다.

15) 표준적인 패치 포맷

패치의 표준적인 subject 라인은 다음과 같습니다:

    Subject: [PATCH 001/123] subsystem: summary phrase

표준적인 패치의 본문에는 다음 내용이 들어갑니다:

  - "from" 라인 : 패치 저자를 기술

  - 빈 라인

  - 패치에 대한 설명, 이 설명이 이 패치를 기술하는 changelog로 복사되어
    영원히 남습니다.

  - "Signed-off-by:" 라인들 : 위의 설명과 같음. 역시 changelog에 남음

  - "---" : 구분하기 위한 기호  

  - changelog에 포함되기엔 적합하지 않은 추가적인 코멘트 
  
  - 실제 패치 (diff 출력)

Subject 라인의 포맷은 순서 번호를 0으로부터 시작함으로써, 숫자나 문자가
섞여 있는 경우에도 정렬 결과를 같게 만듦으로써, 이메일을 제목을 기준으로
정렬하기 쉽게 만들어 줍니다. (대부분의 메일 프로그램이 이 정렬을 지원합니다.)

메일 제목의 "subsystem"에는 반드시 패치가 적용되는 커널의 영역 또는
서브시스템을 지정합니다.

메일 제목의 "summary pharase"는 이 이메일이 담고 있는 패치에 대한 간략한
설명을 담습니다. "summary phrase"가 파일 이름이어서는 안됩니다. 일련의
패치("patch series", 여러 개의 관련된 순서대로 제출된 패치)를 제출하는
경우, 각 패치에 모두 같은 "summary phrase"를 사용하지 마시기 바랍니다.

당신의 메일에 적힌 "summary phrase"는 그 패치에 대한 글로벌한 식별자가
됨을 명심하시기 바랍니다. 그것이 git changelog에 그대로 전달됩니다.
"summary phrase"는 그 패치에 대한 개발자 사이의 토론에도 사용됩니다.
사람들은 토의 내용을 확인하기 위해 그 "summary pharse"를 검색하게 될
것입니다. 또, 두 세 달 뒤에, "gitk" 또는 "git log --oneline" 같은 도구로 
수 천 개의 패치를 뒤질 때, 유일하게 보게 될 문구입니다.

이러한 이유 때문에 "summary"는 70-75 글자를 넘어서는 안되며, 그 패치가
바꾸는 것들과 왜 그 패치가 필요한지를 기술해야 합니다. 간결하면서도 충분히
설명하는 것은 도전적이지만, 잘 써진 요약이란 것이 원래 그런 것 입니다.

"summary phrase"가 "Subject: [PATCH tag] <summary phrase>"와 같이
꺽쇠괄호안의 태그 뒤에 나올 수 있습니다. 이 경우 태그들은 summary phrase의
일부로 인정되지 않지만, 어떻게 그 패치가 취급되어야 하는지를 기술합니다.
통상적으로 코멘트에 대한 대응으로 여러 버전의 패치를 제출하는 경우, 태그는
버전 번호(예, "v1, v2, v3")를 포함하거나, 코멘트를 요청하는 경우엔, "RFC"
(request for comment)를 포함합니다. 일련의 패치가 4개로 이루어진 경우
각 패치에는 1/4, 2/4, 3/4, 4/4와 같이 번호를 붙입니다. 이렇게 해야 개발자들이
어떤 순서로 패치를 적용해야하는지를 확실하게 이해할 수 있으며, 일련의 패치
안의 모든 패치들이 리뷰되고 적용되었는지도 확인할 수 있습니다.

두가지 Subject 라인의 예

    Subject: [patch 2/5] ext2: improve scalability of bitmap searching
    Subject: [PATCHv2 001/207] x86: fix eflags tracking

"from"은 메시지 바디의 가장 첫번째에 오는 라인이며 다음과 같은 형태입니다:

        From: Original Author <author@example.com>

"from" 라인은 그 패치의 저자로 changelog에 영원히 남게 될 사람을 지정합니다.
만일 "from" 라인이 없다면 이메일 헤더의 "From:" 줄에 있는 사람을 패치 저자로
changelog에 기록합니다.

설명을 위한 본문은 changelog에 영원히 저장되는 내용이기 때문에, 이 패치가
어떻게 나오게 되었는지에 관한 구체적인 논의 과정을 잊은지 오래되었다해도
능력있는 독자라면 이해할 수 있는 것이어야 합니다. 이 패치를 만들게 된 증상
(커널 로그 메시지, oops 메시지 등) 등은 적용가능한 패치를 찾기 위해
커밋 로그를 검색하는 사람에게는 특히 유용합니다. 만약 패치가 컴파일 오류를
수정한 것이라면 아마도 ^모든^ 컴파일 에러를 다 포함시킬 필요는 없을 것이며,
다만 패치를 검색하는 사람이 해당 패치를 찾을 수 있을 정도면 충분합니다.
"summary phrase"처럼, 간결하면서도 충분한 설명이 되도록 쓰는 것이 중요합니다.

"---" 표시는 패치를 처리하는 프로그램들이 어디에서 changelog 메시지가
끝나는지를 구분하기 위하여 꼭 필요합니다.

"---" 표시 뒤쪽의 추가적인 코멘트는 어떤 파일들이 수정되었는지, 또 파일에서
몇 라인이 삭제되고 삭제되었는지를 보여주는 diffstat을 위한 것입니다.
diffstat은 특히 긴 패치에 큰 도움이 됩니다. 그리고 특정 시점 또는
관리자에게만 의미가 있는 내용으로 changelog에 기록되기에는 적합하지 않은
코멘트들도 여기에 씁니다. 그런 코멘트의 좋은 예는 "patch changelog"로
해당 패치의 v1과 v2 사이에 변한 것이 무엇인가를 기술하는 것입니다. 

"---" 표시 다음에 diffstat 결과를 기술하려면, diffstat 옵션으로
"-p 1 -w 70"을 지정하여 파일 이름들이 커널 소스 트리의 맨 위부터 나올 수
있도록 하고, (약간의 들여쓰기를 포함해서 80 컬럼에 들어갈 수 있도록) 너무
많은 공백 문자를 사용하지 않도록 합니다

올바른 패치 형식에 대한 구체적인 내용은 아래의 참고문헌들을 보시기 바랍니다.
 
16) "git pull" 요청 보내기 (Linus의 메일에서 가져온 글)
 
git 리파지터리 주소와 브랜치 이름만을 같은 라인에 쓰시기 바랍니다. 그래야
실수로 잘못된 브랜치에서 pull을 하지 않을 수 있고, 트리플 클릭으로 그 한 줄을
선택할 수 있게 됩니다. 

결국, 올바른 포맷은 다음과 같이 라인을 구분하여 쓰는 것입니다:

	"Please pull from

		git://jdelvare.pck.nerim.net/jdelvare-2.6 i2c-for-linus

	 to get these changes:"

위 예처럼 쓰면, 주소를 한 글자씩 보면서 입력하다가 틀리는 경우가 없어집니다.
(실제로 틀린 경우가 몇번 되지는 않으며, diffstat이 뭔가 잘못되었다는 것을
알게 해주지만, pull이 제대로 되었는지를 확인하지 않고, 또 브랜치 이름을
다시 확인하지 않을 수 있다면 참 편할 겁니다.)

diffstat를 만들 때는 반드시 "git diff -M --stat --summary"를 사용하시기
바랍니다. -M은 파일명 변경을 검출하며, --summary는 새로 만들어지거나 지워진
또는 이름이 바뀐 파일에 대한 요약를 만들어 줍니다.
 
파일명 변경 검출을 지정하면, 결과가 사뭇 다르게 나옵니다 [...]
git이 상당히 많은 수정이 파일명 변경이라는 것을 알려주기 때문입니다.

----------------------------------------
제 2 절 - 힌트, 조언, 그리고 요령 몇가지
----------------------------------------

이 절에서는 커널에 제출되는 코드와 관련하여 보통 사용되는 "규칙"들을
나열합니다. 언제나 예외는 있지만... 예외에는 충분한 이유가 있어야 합니다.
이 절을 "Linus의 컴퓨터 기초 강좌"라고 불러도 좋겠습니다.


1) Documentation/CodingStyle 문서 읽기

Nuff 다음과 같이 말했습니다. "만일 당신의 코드가 이 글과 좀 많이 멀어져
있다면, 아마도 더 이상의 리뷰나, 코멘트 없이 거절될 가능성이 높습니다."

이에 대하여 중대한 예외가 하나 있는데, 그것은 한 파일의 코드 일부분을
다른 파일로 옮길 때입니다. 그 경우, 옮겨지는 코드를 전혀 수정해서는 안됩니다.
그래야 코드를 이동한 것과 변경한 것을 명확하게 구분할 수 있게 됩니다.
이로서 실제 차이를 리뷰하고, 도구들이 코드 자체의 역사를 더 잘 추적할 수
있게 됩니다.

제출하기 전에, 당신의 패치를 패치 스타일 검사기(scripts/checkpatch.pl)로
검사하시기 바랍니다. 스타일 검사기는 최종 결정용이 아닌 가이드로 사용하면
됩니다. 당신의 코드가 위반에도 불구하고 더 나아보인다면 그냥 두는 것이
더 좋을 겁니다.

검사기는 다음과 같이 세 단계의 결과를 보고합니다:
  - ERROR: 아마도 높은 확률로 틀렸을 가능성이 있는 것
  - WARNING: 세심한 리뷰가 필요한 것
  - CHECK: 좀 더 생각해봐야 하는 것

당신의 코드에 위반된 내용이 남아 있다면, 그 각각에 대하여 뭔가 정당성이
있어야 할 것입니다.  

2) #ifdef 사용의 자제

ifdef 들로 지저분해진 코드는 읽기도 어렵고 보수 유지도 어렵습니다.
사용하지 마시기 바랍니다. ifdef 대신에 'static inline' 함수를 조건에 따라
선언하는 방식으로 헤더에서 사용하고, 그 함수를 코드에 사용하는 것이 좋습니다.
그 함수가 아무 일도 하지 않는다면 컴파일러가 무시하게 될 겁니다.

간단한, 좋지 않은 코드 예:

	dev = alloc_etherdev (sizeof(struct funky_private));
	if (!dev)
		return -ENODEV;
	#ifdef CONFIG_NET_FUNKINESS
	init_funky_net(dev);
	#endif

깨끗한 코드의 예:

(헤더 파일의 내용)
	#ifndef CONFIG_NET_FUNKINESS
	static inline void init_funky_net (struct net_device *d) {}
	#endif

(코드 자체의 내용)
	dev = alloc_etherdev (sizeof(struct funky_private));
	if (!dev)
		return -ENODEV;
	init_funky_net(dev);

3) 매크로보다는 'static inline' 사용을 권장

static inline 함수는 데이터형에 관한 안전성도 높고, 길이 제한이 없으며,
포맷에 대한 제한도 없고, gcc를 쓴다면 성능도 매크로만큼 좋으므로
매크로보다 훨씬 좋습니다. 

매크로는 static inline이 명확하게 최적의 방법이 아닌 경우 (성능 개선을
위한 몇 가지 특별한 경우가 여기에 해당) 또는 static inline 함수를 원래
사용할 수 없던 경우(예, 매크로 인자의 문자열을 연결할 때)에만 사용합니다.

'static __inline__', 'extern inline', 'extern __inline__' 보다는
'static inline'을 사용하시기 바랍니다.

4) 설계에 너무 집착하지 않기

미래에 쓸모가 있을지 없을지도 모르는 경우를 고려해서 설계하려고
노력하지 마세요: "더 간단해지지 않을만큼 간단하게 만드세요"

-----------------
제 3 절 참고 문헌
-----------------

Andrew Morton, "The perfect patch (완벽한 패치)" (tpp).
  <http://userweb.kernel.org/~akpm/stuff/tpp.txt>

Jeff Garzik, "Linux kernel patch submission format (커널 패치 제출 양식)".
  <http://linux.yyz.us/patch-format.html>

Greg Kroah-Hartman, "How to piss off a kernel subsystem maintainer
(커널 서브시스템 관리자를 열받게 하는 방법)".
  <http://www.kroah.com/log/linux/maintainer.html>
  <http://www.kroah.com/log/linux/maintainer-02.html>
  <http://www.kroah.com/log/linux/maintainer-03.html>
  <http://www.kroah.com/log/linux/maintainer-04.html>
  <http://www.kroah.com/log/linux/maintainer-05.html>

NO!!!! No more huge patch bombs to linux-kernel@vger.kernel.org people!
(No !!! linux-kernel@vger.kernel.org에 대형 패치 폭탄을 보내지 마세요 !)
  <http://marc.theaimsgroup.com/?l=linux-kernel&m=112112749912944&w=2>

Linus Torvalds의 기본 패치 포맷에 관한 메일:
  <http://lkml.org/lkml/2005/4/7/183>

Andi Kleen, "On submitting kernel patches (커널 패치에 대하여)"
  어렵거나 논란이 있는 변경이 받아들여지도록 하는 몇가지 작전
  http://halobates.de/on-submitting-patches.pdf

--
